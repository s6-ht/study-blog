# 从 url 输入到页面加载完成发生了什么？

浏览器内核就是渲染引擎


1. dns 解析(目的/解析过程)
解析过程：浏览器自身缓存、hosts、路由器缓存
2. 浏览器与服务器交互的过程
- tcp 连接(同时 tcp 连接个数限制，超过个数则等待，不超过则开始三次握手)
- http 请求（请求行、请求头、请求体(get 没有)）
- 响应（响应行、响应头和响应体）
  通过 keep-alive 查看是否断开连接(四次挥手)
3. 浏览器渲染过程
- 解析 DOM(标记化、生成 dom 树)
  -  标记化生成tokens
  - 生成 dom 树（其中最重要的是建立起每个节点的父子和兄弟关系。浏览器每收到一段 html 的文本之后，就会把它序列化成一个个的 tokens，依次遍历这些 token，实例化成对应的 html 结点并插入到 DOM 树里面。）

生成父子兄弟关系的流程：

一个开标签栈arr和一个每次遇到闭标签的标志m_lastChild
body: arr: [body]
div: arr: [body, div] 此时div的父节点为body
span: arr: [body, div, span] 此时span的父节点为div
遇到闭合的span标签:  arr: [div, span] 此时m_lastChild = </span>
p: arr: [body, div, p]  此时p的父节点为div
遇到闭合的p, arr: [body, div] 由于m_lastChild存在，所有p标签的前一个兄弟节点为span, 并将span的下一个兄弟节点设置为p

遇到闭合的div, arr: [body]
遇到闭合的body, arr: []

```javascript
<body>
  <div>
    <span></span>
    <p></p>
  </div>
</body>
```

生成 css 树（格式化、标准化、计算每个节点的具体样式）
生成 layout 树(遍历生成的dom树节点，将其添加进布局树中；计算布局树中节点的位置)

- 渲染
1. 建图层树，浏览器在构建完布局树之后，还会对特定的节点进行分层，构建一棵图层树(Layer Tree)，opacity、transform、will-change，position｜z-index都会被单独提升为一个图层。如果发生重绘，则只会重绘本身，而不会影响到其它图层。
2. 生成绘制列表，将图层的绘制拆分成一个个的指令，相当于将这些指令按照顺序组合成了一个待绘制列表。
3. 生成图块，绘制操作由合成线程完成。绘制列表准备好了之后，渲染进程的主线程会给合成线程发消息，将绘制列表传给合成线程。
- 将图层分为图块。是因为如果页面特别大，一口气全部绘制完是特别耗费性能的。
- 将图层转化为位图。这个过程由栅格化来执行。渲染进程中维护了一个栅格化线程池，合成线程会选择视口附近的图块，将其交给栅格化线程池处理，生成位图的过程实际上都会使用 GPU 进行加速，处理完成后将位图发送给合成线程。
4. 合成与显示。栅格化操作完成后，合成线程生成一个绘制命令，发送给浏览器进程，浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。
>无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。比如某个动画大量占用内存时，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。


GPU加速原理
产生GPU加速的方式：transform、opacity、filter属性

使用上面这些方式时，会跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。这样做的好处：
- 充分发挥GPU的优势，在生成位图的过程中，会调用线程池，并且使用GPU加速生成。
- 没有占用主线程的资源，即便主线程卡住了，也可以流畅展示。


回流的过程会从构建DOM树开始，直到显示在显卡中。
重绘是从生成绘制列表流程开始，到最后。

帧率，60fps，可以理解为一秒钟的动画是由60张静态图片连在一起的，所以如果卡了，就是失帧或者掉帧了。在渲染过程中，静态图片可能就是生成的位图（个人理解）。60fps就要求1帧的时间为1s / 60 = 16.67ms，在每一帧里需要执行js/style/layout/绘制/合成这些操作，这几项的任何一项如果执行时间太长了，就会导致渲染这一帧的时间太长，平均帧率就会掉。那么如何解决耗时的JS呢？

requestIdleCallback
requestIdleCallback 会在每次 check 结束发现距离下一帧的刷新还有时间，就执行一下这个。如果时间不够，就下一帧再说。

requestAnimationFrame
JS执行完成后，开始渲染之前会有一个生命周期requestAnimationFrame。requestAnimationFrame 是每次 loop 结束发现需要渲染，在渲染之前执行的一个回调函数，不是宏微任务。


dom离线操作：也就相当于创建一个文档片段，将要改变的内容都放在这里，然后一次性操作。