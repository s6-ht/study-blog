# 浏览器中的事件循环机制

#### 浏览器的线程
浏览器是多线程的，不同的线程处理不同的任务，它分为以下几个线程：
- JS线程
- UI线程
- 事件线程（click...）
- 定时器线程（setTimeout...）
- 异步http线程

其中JS线程和UI线程互斥，即两者不能同时进行。那么为了利用多核CPU的计算能力，html5提出了web worker标准，允许javascript创建多个线程，但是这些线程都受到主线程的控制，且不能操作dom。因此，javascript是单线程的，一个主线程，多个子线程。

JS中任务被分为同步任务和异步任务。同步任务会在调用栈中按照顺序执行；异步任务被**浏览器对应的线程**处理后，将其注册的回调函数放入任务队列；等待主线程空闲的时候从任务队列中读取任务执行。

#### 1. 宏任务
- script整体代码
- setTimeout
- setInterval
- I/O
- setImmediate
- UI Rendering

#### 2. 微任务
- Promise.then
- MutationObserver

#### 3. 执行机制
- script整体代码作为第一个宏任务执行
- 遇到同步代码直接执行，遇到宏任务，被浏览器相应的线程处理后，添加其回调进宏任务队列，微任务的回调添加进微任务队列
- 当前宏任务执行完成，检查微任务队列，有则执行，知道微任务队列清空
- 执行浏览器的UI渲染任务（在渲染之前有一个requestAnimationFrame的生命周期）
- 检查是否有Web worker任务，有则执行（在这一步结束后，requestIdleCallback可以检查到距离下一帧的刷新是否还有时间， 可以在这里执行一些以前帧没执行完的任务）
- 从宏任务队列中取出第一个宏任务，循环以上步骤，知道队列清空

